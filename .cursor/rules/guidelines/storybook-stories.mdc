---
description: How to write Storybook stories
globs: *.stories.tsx
alwaysApply: false
---

# Writing Storybook Stories

Use Component Story Format (CSF).

## Basic Structure

```tsx
import type { Meta, StoryObj } from '@storybook/react'

const meta: Meta<typeof YourComponent> = {
	title: 'components/YourComponent',
	tags: ['autodocs'],
	component: YourComponent,
} satisfies Meta

export default meta
type Story = StoryObj<typeof meta>

export const BasicUsage: Story = { }
```

## Story Organization

1. **Files**: Place next to component, use `.stories.tsx`, name `component-name.stories.tsx`
2. **Naming**: Default story is `BasicUsage`, others descriptive (`WithError`, `Loading`). Use `name` property if PascalCase is confusing:
```ts
export const Red100: Story = { name: 'red-100' }
```
3. **Description**: Use `defineDocsParam` for additional story description:
```ts
import { defineDocsParam } from '@repobuddy/storybook'
export const SomeStory: Story = {
	parameters: defineDocsParam({
		description: { story: 'Additional message' },
	}),
}
```

## Story Implementation Patterns

1. **Property order**: `name`, `tags`, `parameters`, `args`, `loaders`, `decorators`, `render`, `play`, `afterEach`

2. **Render function**: Use to emphasize testing subject. Extract complex UI into components:
```tsx
// ✅ Good - Extract LogPanel component
export const OnChange: Story = {
	render() {
		const [logs, setLogs] = useState<string[]>([])
		return (
			<div>
				<RadioGroup onChange={(v) => setLogs([...logs, `changed: ${v}`])}>
					<Radio value="apple">Apple</Radio>
				</RadioGroup>
				<LogPanel logs={logs} />
			</div>
		)
	},
}
// ❌ Bad - Inline styles create noise, extract to component
```

3. Prefer CSS classes or Tailwind CSS over inline styles.

## Testing and Documentation

- Stories serve as visual tests and documentation
- Include edge cases and error states
- Document component props and usage
- Use `defineDocsParam` for additional documentation
- Use `play` function to interact and validate behavior

## Example

```tsx
import type { Meta, StoryObj } from '@storybook/react'
import { CopyButton } from './copy-button.tsx'

const meta = {
	title: 'components/CopyButton/isDisabled',
	component: CopyButton,
	tags: ['autodocs'],
} satisfies Meta<typeof CopyButton>

export default meta
type Story = StoryObj<typeof meta>

export const Enabled: Story = {
	name: 'isDisabled: false',
	args: { label: 'Copy Button', isDisabled: false },
}

export const Disabled: Story = {
	name: 'isDisabled: true',
	args: { label: 'Copy Button', isDisabled: true },
}
```

## Best Practices

1. Keep stories simple and focused
2. Test all component variations
3. Include interactive examples where relevant
4. Use TypeScript for type safety

## Checklist

- [ ] `.stories.tsx` extension, placed next to component
- [ ] CSF format with TypeScript
- [ ] Proper imports (React hooks if used)
- [ ] Default story named `BasicUsage`
- [ ] Properties follow recommended order
- [ ] Complete, runnable code examples
- [ ] Documentation with `defineDocsParam` when needed
